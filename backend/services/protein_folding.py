import asyncio
from typing import Optional
import aiohttp
import json
from core.config import settings

class ProteinFoldingService:
    def __init__(self):
        self.max_sequence_length = 400
        self.esmfold_api_url = "https://api.esmatlas.com/foldSequence/v1/pdb/"
    
    def _clean_sequence(self, sequence: str) -> str:
        """Clean and validate the input sequence"""
        if not sequence or not isinstance(sequence, str):
            raise ValueError("Invalid sequence provided")
        
        # Remove any non-amino acid characters
        valid_aa = 'ARNDCQEGHILKMFPSTWYV'
        cleaned = ''.join(c.upper() for c in sequence if c.upper() in valid_aa)
        
        if not cleaned:
            raise ValueError("No valid amino acids found in sequence")
            
        return cleaned
    
    async def fold_sequence_esmfold(self, sequence: str) -> Optional[str]:
        """Fold protein sequence using ESMFold API"""
        try:
            # Use the new validation method
            cleaned_sequence = self._clean_sequence(sequence)
        except ValueError as e:
            print(f"Sequence validation error: {e}")
            return None
            
        if len(cleaned_sequence) > self.max_sequence_length:
            print(f"Sequence too long ({len(cleaned_sequence)} chars), truncating...")
            cleaned_sequence = cleaned_sequence[:self.max_sequence_length]
        
        try:
            print(f"Predicting structure for sequence: {cleaned_sequence[:50]}...")
            print(f"DEBUG: Using REAL ESMFold API for sequence length {len(cleaned_sequence)}")
            
            # Use ESMFold API instead of local installation
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    self.esmfold_api_url,
                    data=cleaned_sequence,
                    headers={"Content-Type": "text/plain"}
                ) as response:
                    
                    if response.status == 200:
                        pdb_string = await response.text()
                        print("SUCCESS: Real ESMFold API prediction completed!")
                        print(f"DEBUG: PDB output starts with: {pdb_string[:100]}...")
                        return pdb_string
                    else:
                        error_text = await response.text()
                        print(f"ESMFold API error: {response.status} - {error_text}")
                        print("WARNING: Falling back to alpha-helix model")
                        return await self._generate_fallback_structure(cleaned_sequence)
                        
        except Exception as e:
            print(f"Error in ESMFold API call: {e}")
            print("WARNING: Falling back to alpha-helix model")
            return await self._generate_fallback_structure(cleaned_sequence)
    
    async def _generate_fallback_structure(self, sequence: str) -> str:
        """Generate a simple alpha-helix structure as fallback"""
        print("FALLBACK: Generating alpha-helix model structure")
        
        from Bio.Seq import Seq
        import math
        
        # Convert to amino acids if it's DNA
        try:
            if all(c in 'ATCGN' for c in sequence.upper()):
                bio_seq = Seq(sequence)
                aa_sequence = str(bio_seq.translate()).replace('*', '')
                print(f"FALLBACK: Translated DNA to amino acids: {aa_sequence[:20]}...")
            else:
                aa_sequence = ''.join(c for c in sequence.upper() if c in 'ARNDCQEGHILKMFPSTWYV')
                print(f"FALLBACK: Using amino acid sequence: {aa_sequence[:20]}...")
        except Exception as e:
            print(f"FALLBACK: Translation error: {e}, using default sequence")
            aa_sequence = "MKLAVLVAGVCGSC"
        
        if len(aa_sequence) > 50:
            aa_sequence = aa_sequence[:50]
        
        if not aa_sequence:
            aa_sequence = "MKLAVLVAGVCGSC"
        
        # Generate realistic alpha-helix coordinates
        pdb_lines = []
        pdb_lines.append("HEADER    PROTEIN STRUCTURE PREDICTION")
        pdb_lines.append("COMPND    PREDICTED STRUCTURE")
        pdb_lines.append("REMARK   1 GENERATED BY BIOSYNTH-XTREME (FALLBACK)")
        pdb_lines.append("REMARK   2 USING SIMPLIFIED ALPHA-HELIX MODEL")
        
        # Amino acid single letter to three letter conversion
        aa_3letter = {
            'A': 'ALA', 'R': 'ARG', 'N': 'ASN', 'D': 'ASP', 'C': 'CYS',
            'Q': 'GLN', 'E': 'GLU', 'G': 'GLY', 'H': 'HIS', 'I': 'ILE',
            'L': 'LEU', 'K': 'LYS', 'M': 'MET', 'F': 'PHE', 'P': 'PRO',
            'S': 'SER', 'T': 'THR', 'W': 'TRP', 'Y': 'TYR', 'V': 'VAL'
        }
        
        atom_count = 1
        for i, aa in enumerate(aa_sequence):
            if aa not in aa_3letter:
                print(f"FALLBACK: Skipping invalid amino acid: {aa}")
                continue
                
            aa_code = aa_3letter[aa]
            print(f"FALLBACK: Processing {aa} -> {aa_code} at position {i+1}")
            
            # Alpha helix parameters
            angle = i * 100 * math.pi / 180
            radius = 2.3
            rise_per_residue = 1.5
            
            # Backbone atoms with realistic coordinates
            backbone_atoms = [
                ('N', 0.0, 0.0, 0.0),
                ('CA', 1.46, 0.0, 0.0),
                ('C', 2.04, 1.23, 0.0),
                ('O', 3.26, 1.23, 0.0)
            ]
            
            for atom_name, dx, dy, dz in backbone_atoms:
                x = radius * math.cos(angle) + dx
                y = radius * math.sin(angle) + dy
                z = i * rise_per_residue + dz
                
                # Format PDB line properly with correct 3-letter amino acid codes
                pdb_line = f"ATOM  {atom_count:5d}  {atom_name:<4s}{aa_code} A{i+1:4d}    {x:8.3f}{y:8.3f}{z:8.3f}  1.00  20.00           {atom_name[0]}"
                pdb_lines.append(pdb_line)
                atom_count += 1
        
        pdb_lines.append("END")
        result = "\n".join(pdb_lines)
        
        print(f"FALLBACK: Generated structure with {atom_count-1} atoms")
        print(f"FALLBACK: First line: {pdb_lines[4] if len(pdb_lines) > 4 else 'No atoms'}")
        
        return result
    
    async def get_alphafold_prediction(self, sequence: str) -> Optional[str]:
        """Get protein structure prediction"""
        try:
            return await self.fold_sequence_esmfold(sequence)
        except Exception as e:
            print(f"Error in structure prediction: {e}")
            return await self._generate_fallback_structure(sequence)

# Create a global instance
protein_folder = ProteinFoldingService()